\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{listings}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage[normalem]{ulem}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{titlesec}

\usepgfplotslibrary{units}
\pgfplotsset{compat=1.16}
\geometry{left=25mm, right=10mm, top=20mm, bottom=20mm}

\renewcommand{\thepart}{\arabic{part}}
\renewcommand{\thesection}{\thepart.\arabic{section}}

\begin{document}
    \input{parts/title.tex}

    \newpage

    \section*{Постановка задачи}
    Разработать клиент-серверное приложение для вывода на внешний жидкокристаллический
    дисплей (с помощью Raspberry Pi) количества сокращенных ссылок из базы данных сервиса short.taxnuke.ru в режиме реального времени.

    \section*{Ход работы}
    \begin{figure}
        \includegraphics[width=\linewidth]{img/arch.jpg}
        \caption{Схема архитектуры крупным планом.}
        \label{fig:big_arch}
    \end{figure}

    На рисунке~\ref{fig:big_arch} изображена схема сервиса short.taxnuke.ru в целом, а также интегрированного в него
    разрабатываемого клиент-серверного приложения (в пунктирной фиолетовой рамке).

    В качестве программной среды было принятно решение использовать Node.js - кроссплатформенное решение,
    использующее в качестве JavaScript-движка V8, написанный на C. Для Node.js имеется множество готовых библиотек
    на JavaScript с привязками к нативным модулям на C++ и C и с многопоточностью.
    Выбор обусловлен тем, что изначально сервис short.taxnuke.ru тоже написан Node.js и использоание
    одной программной среды и языка позволяет минимизировать количество зависимостей и упростить интерфейс между компонентами.
    Также Node.js позволяет порождать дочерние процессы и передавать в них аргументы командной
    строки, управляющие последовательности и использовать потоки ввода/вывода.

    \subsection*{Проработка архитектуры и регламента взаимодействия между сервисами}
    В первую очередь необходимо было продумать, какие механизмы и средства будут использоваться для взаимодействия
    сервисом между собой и сервиса статистики и его потребителей. В качестве протокола для общения сервиса статистики и его клиентов
    было решено использовать websocket, чтобы избежать опрашивания основного
    сервиса (даже "длинного" опрашивания), которое неизбежно повлекло бы за собой ухудшение производительности основного сервиса
    при количестве клиентов (потребителей статистики оного), стремящемся к бесконечности.

    В качестве механизма взаимодействия сервисов между собой был выбран webhook, то есть один сервис будет
    отправлять http-запрос любым методом в любой эндпоинт другого сервиса с целью просто "дернуть" его и уведомить
    о том, что данные обновились. Было решено также не передавать с webhook никаких данных от одного сервиса к другому,
    это позволило избежать лишних развертываний основного сервиса по причинам изменений в интерфейсе сервиса статистики или формата данных.

    Вместо этого, сервис статистики открывает свое личное соединение с базой данных и по пришествии webhook сам
    параллельно отправляет к базе запрос и реализует там своими средствами всю бизнес логику, инкапсулируя ее от основного сервиса.

    \subsection*{Создание фундамента}
    Было принято решение использовать монорепозиторий git для управления контролем версий проекта, ввиду того, что
    логически это один т.н. микросервис, в дополнение к тому, что клиент и сервер изоморфны и используют одни библиотеки
    и написаны на одном языке.

    В качестве линтера (утилиты контроля качества кода) используется eslint, его конфигурационный файл можно увидеть в
%    todo: надо автоматически нумеровать
    приложении 4.

    В качестве сиситемы доставки и развертки используется стандартная для Node.js связка из pm2 и git. pm2 на машине-разработчике
    подключается к машине-исполнителю по ssh, выполняет git clone, разворачивает проект из исходого кода и переставляет символьную ссылку
    на последний релиз, а так же берет на себя управление переменными окружения. Конфигурационный файл pm2 можно увидеть
    в приложении 3

    \subsection*{Разработка сервиса-сервера}
    В качестве библиотеки для работы с websocket была выбрана самая популярная - "ws". Драйвер для общения с базой
    данных MongoDB было решено использовать официальный - "mongodb".

    При первом старте, сервер пытается подключиться к базе данных, если все произошло успешно, то создается http-сервер,
    который слушает на порт из переменной окружения, и аналогично далее создается websocket-сервер.

    При установлении нового соединения, сервер websocket отпрвляет тестовые данные для подтверждения соединения,
    и через 3 секунды отправляет клиенту актуальную информацию о статистике. Далее, websocket-сервер оповещает
    своих клиентов только после получения webhook от основного сервиса, при этом обновляя информацию о статистике.

    Исходный код сервера находится в приложении 1.

    \subsection*{Разработка сервиса-клиента}
    В качестве библиотеки для работы с websocket была также выбрана "ws". При старте сервис-клиент пытается установить
    соединение с сервисом-сервером по websocket и далее выводит информацию на жидкокристаллический экран с помощью библиотеки
    "lcdi2c", которая позволяет абстрагироваться от низкоуровневой логики общения по протоколу I2C.

    Исходный код клиента находится в приложении 2.

    \section*{Результат работы}
    В результате выполнения курсового проекта было разработано серверное и клиентское приложения,
    работающие в паре и выполняющие поставленную задачу.

    \newpage
    \subsection*{ПРИЛОЖЕНИЕ 1. Код сервера}
    \lstinputlisting{../source/server.js}

    \newpage
    \subsection*{ПРИЛОЖЕНИЕ 2. Код клиента}
    \lstinputlisting{../source/client.js}

    \newpage
    \subsection*{ПРИЛОЖЕНИЕ 3. Содержимое конфигурационного файла для развертки}
    \lstinputlisting{../ecosystem.config.js}

    \newpage
    \subsection*{ПРИЛОЖЕНИЕ 4. Конфигурация линтера}
    \lstinputlisting{../.eslintrc.js}


\end{document}
